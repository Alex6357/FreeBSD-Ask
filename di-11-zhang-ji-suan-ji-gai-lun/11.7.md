# 第 11.7 节 命令行基础

## 登录到 FreeBSD

当你安装 FreeBSD 后，如果一切正常，你应该会在屏幕上看到以下内容：

```sh
FreeBSD/amd64 (ykla) (ttyv0)

login:
```

我们将这个屏幕上呈现的界面称为 TTY（teletypewriter，电传打字机）或物理终端。

解释：
- `FreeBSD` 是操作系统名称；
- `amd64` 是体系架构，一般英特尔和 AMD 处理器都是 amd64，即 x86-64；
- `ykla` 是主机名，是在安装系统时你自己设置的；
- `ttyv0` 是指首个 TTY，你会发现计算机中大部分事物的序列都是以 0 打头的；
- `login:` 指示用户登录。

我们输入用户名和密码，以登录到系统：

```sh
FreeBSD/amd64 (ykla) (ttyv0)

login:root # 此处输入用户名，然后按回车键
password: # 此处输入密码，然后按回车键
Last login: Tue Mar 18 17:24:48 2025 from 3413e8b6b43f
FreeBSD 15.0-CURRENT (GENERIC) main-n275981-b0375f78e32a

Welcome to FreeBSD!

Release Notes, Errata: https://www.FreeBSD.org/releases/
Security Advisories:   https://www.FreeBSD.org/security/
FreeBSD Handbook:      https://www.FreeBSD.org/handbook/
FreeBSD FAQ:           https://www.FreeBSD.org/faq/
Questions List:        https://www.FreeBSD.org/lists/questions/
FreeBSD Forums:        https://forums.FreeBSD.org/

Documents installed with the system are in the /usr/local/share/doc/freebsd/
directory, or can be installed later with:  pkg install en-freebsd-doc
For other languages, replace "en" with a language code like de or fr.

Show the version of FreeBSD installed:  freebsd-version ; uname -a
Please include that output and any error messages when posting questions.
Introduction to manual pages:  man man
FreeBSD directory layout:      man hier

To change this login announcement, see motd(5).
root@ykla:~ #
```

祝贺你！你已经成功地登录到了 FreeBSD 操作系统。

>**注意**
>
>密码并不会被回显打印到屏幕上：一般我们输入密码时，屏幕上会显示 `******`。但是在 FreeBSD 中，凡是涉及密码的地方大都不会有任何显示，即使输入了密码屏幕上也是空白的，和没有任何输入是一个状态，就是什么也没有，输入后回车即可。

### 参考文献

- [What is TTY in Linux?](https://itsfoss.com/what-is-tty-in-linux/)，翻译在 [Linux 黑话解释：TTY 是什么？](https://linux.cn/article-14093-1.html)。



## 命令行格式

大部分命令行命令都应是有意义的，例如 `ls` 即 `list`（列出来）、`wget` 即通过 web（网络）来 `get`（下载）；罕有一些见名不知意的命令，比如 `fuck` 命令（可自动纠正拼写错误的命令）。

```sh
# 命令 选项  参数1       参数2
# ls   -l   /home/ykla /tmp
/home/ykla:
total 317
……省略一部分……
drwxr-xr-x  2 ykla ykla        2 Mar  9 20:45 下载
drwxr-xr-x  2 ykla ykla        2 Mar  9 20:45 公共
drwxr-xr-x  2 ykla ykla        2 Mar  9 20:45 图片
drwxr-xr-x  2 ykla ykla        2 Mar  9 20:45 文档
drwxr-xr-x  2 ykla ykla        2 Mar  9 20:45 桌面
drwxr-xr-x  2 ykla ykla        2 Mar  9 20:45 模板
drwxr-xr-x  2 ykla ykla        2 Mar  9 20:45 视频
drwxr-xr-x  2 ykla ykla        2 Mar  9 20:45 音乐

/tmp:
total 6
drwxrwxrwt  2 root    wheel  3 Mar 18 17:23 .ICE-unix
-r--r--r--  1 root    wheel 11 Mar 18 17:10 .X0-lock
-r--r--r--  1 ykla    wheel 11 Mar 18 17:23 .X10-lock
drwxrwxrwt  2 root    wheel  4 Mar 18 17:23 .X11-unix
drwxrwxrwt  2 root    wheel  2 Mar 18 17:10 .XIM-unix
drwxrwxrwt  2 root    wheel  2 Mar 18 17:10 .font-unix
```

其中，`ls`（L 小写）选项 `-l`（L 小写）意味着打印详细信息。

现在，大部分命令均应遵从上面的方式（有所省略）。这是 [POSIX.1-2024](https://pubs.opengroup.org/onlinepubs/9799919799/) 规范所规定的。

我们需要注意英文和中文是不同的，中文不使用空格进行分割，而英文必须使用空格以示分别。故，命令行的每个部分中间应该有空格，即 ` `。空格的数量一般不受限制，但最少应该为一个，即 ` `。

>**思考题**
>
>如果不使用空格或某种方式（例如其他符号）对命令行进行分隔，那么软件该如何理解整个句子？比如：`ls-l/home/ykla/tmp`、`ls/`：
>
>```sh
>root@ykla:~ # ls-l/home/ykla/tmp
>-sh: ls-l/home/ykla/tmp: not found
>root@ykla:~ # ls/
>-sh: ls/: not found
>```
>
>可以看到，shell 会将整个句子当成一个可执行的命令去执行。

我们还需要知道，命令是不具有自动纠错功能的，哪怕只是打错了一个字母，少了一个数字，命令也绝不会执行成功：

```sh
root@ykla:~ # LS # 试试全大写
-sh: LS: not found
root@ykla:~ # Ls # 一大一小呢
-sh: Ls: not found
root@ykla:~ # ls /hom1 # 实为 /home
ls: /hom1: No such file or directory
root@ykla:~ # ls -z /home # 不存在选项 -z
ls: invalid option -- z
usage: ls [-ABCFGHILPRSTUWZabcdfghiklmnopqrstuvwxy1,] [--color=when] [-D format] [--group-directories=] [file ...]
```

## 命令的执行与中断

与 Windows 以及图形化界面的软件不同，绝大部分命令行程序在执行中是不会有任何进度提示的。通常只有以下两个结果：

- 成功执行：

```sh
root@ykla:~ # cp test /root/mydir/
root@ykla:~ #
```

- 执行中断：

```sh
root@ykla:~ # cp test9 /root/mydir/
cp: test9: No such file or directory
```

执行中断有很多可能的情形，以上只是其中一种（指定的文件或目录不存在）。

可以看到，只有当执行中断时，命令行才会有提示；若执行完毕，是不会有任何提示的。这种 Unix 设计哲学旨在保证终端输出的简洁性。

## Shell

我们的命令是运行在 shell 中的，通过 shell 与系统进行交互。

FreeBSD 默认的 shell 是 sh。基本符合 [IEEE 1003.1-2024](https://standards.ieee.org/ieee/1003.1/7700/) 中对 shell 的规范。

Linux 中常见的 shell 一般是 bash。而 macOS 中的默认 shell 通常是 zsh。

>**注意**
>
>Linux 中也存在 sh，但是一般都是被软链接到了 bash 或其他 shell，她们都不是真正的 sh。
>
>```bash
>$ ls -l /bin/sh
>lrwxrwxrwx 1 root root 4  2月 25 23:19 /bin/sh -> dash
>```

### 快捷键

一般可以用 **Tab** 键补全命令。上箭头 **↑** 是查看上一条命令，下箭头 **↓** 是查看下一条命令。

```sh 
root@ykla:~ # lo # 若此时按 TAB 键，输出如下。可以再输一个字母再按一次 TAB 键看看
local                    localedef                login
local-unbound            locate                   logins
local-unbound-anchor     lock                     logname
local-unbound-checkconf  lockf                    look
local-unbound-control    lockstat                 lorder
local-unbound-setup      locktest                 lowntfs-3g
locale
```

若想终止命令，可以用 **ctrl**+**c**：

```sh
root@ykla:~ # ping 163.com
PING 163.com (59.111.160.244): 56 data bytes
64 bytes from 59.111.160.244: icmp_seq=0 ttl=52 time=27.672 ms
64 bytes from 59.111.160.244: icmp_seq=1 ttl=52 time=27.580 ms
^C # 注意这里，^C 即代表你在此处按下了 ctrl + c 的组合键，随后命令被终止
--- 163.com ping statistics ---
2 packets transmitted, 2 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 27.580/27.626/27.672/0.046 ms
```

**ctrl**+**z**: 把当前进程放到后台，然后用 `fg` 命令可回到前台：

```sh
root@ykla:~ # ping 163.com
PING 163.com (59.111.160.244): 56 data bytes
64 bytes from 59.111.160.244: icmp_seq=0 ttl=52 time=27.611 ms
64 bytes from 59.111.160.244: icmp_seq=1 ttl=52 time=27.691 ms
64 bytes from 59.111.160.244: icmp_seq=2 ttl=52 time=27.701 ms
^Z[1] + Suspended               ping 163.com # 注意此处，按下了 ctrl + z
root@ykla:~ # fg # 返回前台
ping 163.com
64 bytes from 59.111.160.244: icmp_seq=3 ttl=52 time=27.465 ms
64 bytes from 59.111.160.244: icmp_seq=4 ttl=52 time=27.586 ms
64 bytes from 59.111.160.244: icmp_seq=5 ttl=52 time=27.522 ms
^C # 按 crtl + c 结束命令
--- 163.com ping statistics ---
6 packets transmitted, 6 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 27.465/27.596/27.701/0.085 ms
```

其他：
- **ctrl**+**l**（L 的小写）：清空屏幕
- **ctrl**+**a**： 移动光标到命令行首
- **ctrl**+**a**: 移动光标到命令行尾

>**注意**
>
>上述快捷键不一定非要是小写状态才能执行，大写状态下一样可以执行。


## 命令的来源

### Linux

在 Linux 中，所有命令基本上都是来自 GNU 软件包的，Linux 内核没有任何命令。我们来验证这一点：

```bash
ykla@ykla-virtual-machine:~$ dpkg -S /bin/mv 
coreutils: /bin/mv
ykla@ykla-virtual-machine:~$ dpkg -S /bin/cp
coreutils: /bin/cp
ykla@ykla-virtual-machine:~$ dpkg -S /bin/ls
coreutils: /bin/ls
ykla@ykla-virtual-machine:~$ dpkg -S /bin/pwd
coreutils: /bin/pwd
ykla@ykla-virtual-machine:~$ dpkg -S /bin/cat
coreutils: /bin/cat
ykla@ykla-virtual-machine:~$ dpkg -S /usr/sbin/chroot
coreutils: /usr/sbin/chroot
ykla@ykla-virtual-machine:~$ dpkg -S /bin/kill
procps: /bin/kill
ykla@ykla-virtual-machine:~$ dpkg -S /usr/bin/free
procps: /usr/bin/free
ykla@ykla-virtual-machine:~$ dpkg -S /bin/su
util-linux: /bin/su
```

可见在 Linux 中，这些常见命令一般出自 GNU 软件 coreutils、util-linux 或 procps。这些软件在历史上是 GNU 计划对 UNIX 软件的再实现。

同时，shell 本身也内置了一些命令：

```bash
ykla@ykla-virtual-machine:~$ type cd
cd 是 shell 内建
```

列出所有 shell 内置的命令：

```bash
ykla@ykla-virtual-machine:~$ compgen -b
.
:
[
alias
bg
bind
break
builtin
caller
cd
command
compgen
complete
compopt
continue
declare
dirs
disown
echo
enable
eval
exec
exit
export
false
fc
fg
getopts
hash
help
history
jobs
kill
let
local
logout
mapfile
popd
printf
pushd
pwd
read
readarray
readonly
return
set
shift
shopt
source
suspend
test
times
trap
true
type
typeset
ulimit
umask
unalias
unset
wait
```

### FreeBSD

```sh
root@ykla:~ # type cd
cd is a shell builtin
```

在 FreeBSD 中，除了上述 shell 内置命令外（参见 [sh(1)](https://man.freebsd.org/cgi/man.cgi?sh(1))），常用命令都是基本系统自带的，不属于任何一个包。比如 `ls` 命令，其源代码位于 [freebsd-src/bin/ls/](https://github.com/freebsd/freebsd-src/tree/main/bin/ls)。可见 FreeBSD 系统是一个有机整体。并非由不同人员或团队维护的软件包拼凑而成的。

如果你配置了 pkgbase，则输出类似：

```sh
root@ykla:~ # pkg which /bin/ls
/bin/ls was installed by package FreeBSD-runtime-15.snap20250313173555

```


如果缺少了哪个命令，一般可以通过安装相应的软件包来获取，比如 `lspci` 命令，来自软件包 `sysutils/pciutil`。但是也有很多命令存在 Linux 主义问题，不兼容其他操作系统，比如 ip 命令，来自 GNU 软件包 iproute2。


 
